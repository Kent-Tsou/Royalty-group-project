"use strict";

require('dotenv').config();

var express = require('express');

var request = require('supertest');

var endpoints = require('../endpoints');

var functions = {
  getUserByName: function getUserByName() {
    return Promise.resolve({
      id: 1,
      other: 'value',
      hash: 'test-hash',
      username: 'test-user'
    });
  },
  userExists: function userExists() {
    return Promise.resolve(false);
  },
  createUser: function createUser() {
    return Promise.resolve();
  }
};
process.env.JWT_SECRET = 'test-jwt-secret';
describe('applyAuthRoutes', function () {
  beforeEach(function () {
    return jest.resetModules();
  });
  it('creates an operational /auth/register route', function () {
    var _require = require('./routes'),
        applyAuthRoutes = _require.applyAuthRoutes;

    var server = express();
    server.use(express.json());
    var router = express.Router();
    server.use('/', router);
    applyAuthRoutes(router, functions);
    return request(server).post(endpoints.registerUrl).expect(200).send({
      username: 'test-user',
      password: 'test-password'
    }).then(function (res) {
      expect(res.body.message).toMatch('successful');
      expect(res.body.token).toHaveLength(189);
      var request = {
        headers: {
          authorization: "Bearer ".concat(res.body.token)
        }
      };
      var response = {};

      var verifyJwt = require('express-jwt');

      verifyJwt({
        secret: process.env.JWT_SECRET,
        algorithms: ['HS256']
      })(request, response, function (err) {
        if (err) console.error(err);
        expect(request.user.id).toBe(1);
        expect(request.user.other).toBe('value');
        expect(request.user.username).toBe('test-user');
      });
      return null;
    });
  });
  it('creates an operational /auth/signin route', function () {
    jest.mock('./hash', function () {
      return {
        verify: function verify() {
          return Promise.resolve(true);
        }
      };
    });

    var _require2 = require('./routes'),
        applyAuthRoutes = _require2.applyAuthRoutes;

    var server = express();
    server.use(express.json());
    var router = express.Router();
    server.use('/', router);
    applyAuthRoutes(router, functions);
    return request(server).post(endpoints.signInUrl).expect(200).send({
      username: 'test-user',
      password: 'test-password'
    }).then(function (res) {
      expect(res.body.message).toMatch('successful');
      expect(res.body.token).toHaveLength(189);
      return null;
    });
  });
  describe('/auth/register', function () {
    it('returns status 400 if the username is already being used', function () {
      var _require3 = require('./routes'),
          applyAuthRoutes = _require3.applyAuthRoutes;

      var server = express();
      server.use(express.json());
      var router = express.Router();
      server.use('/', router);

      functions.userExists = function () {
        return Promise.resolve(true);
      };

      applyAuthRoutes(router, functions);
      return request(server).post(endpoints.registerUrl).expect(400).send({}).then(function (res) {
        expect(res.body.errorType).toMatch('USERNAME_UNAVAILABLE');
        return null;
      });
    });
    it('returns status 500 if there is a database error', function () {
      var _require4 = require('./routes'),
          applyAuthRoutes = _require4.applyAuthRoutes;

      var server = express();
      server.use(express.json());
      var router = express.Router();
      server.use('/', router);

      functions.userExists = function () {
        return Promise.reject(new Error());
      };

      applyAuthRoutes(router, functions);
      return request(server).post(endpoints.registerUrl).expect(500).send({}).then(function (res) {
        expect(res.body.errorType).toMatch('DATABASE_ERROR');
        return null;
      });
    });
  });
  describe('/auth/signin', function () {
    it('returns a status 400 if no user is returned from the database', function () {
      var _require5 = require('./routes'),
          applyAuthRoutes = _require5.applyAuthRoutes;

      var server = express();
      server.use(express.json());
      var router = express.Router();
      server.use('/', router);

      functions.getUserByName = function () {
        return Promise.resolve(null);
      };

      applyAuthRoutes(router, functions);
      return request(server).post(endpoints.signInUrl).expect(400).send({}).then(function (res) {
        expect(res.body.errorType).toMatch('INVALID_CREDENTIALS');
        return null;
      });
    });
    it('returns a status 400 if the password and hash do not match', function () {
      jest.mock('./hash', function () {
        return {
          verify: function verify() {
            return Promise.resolve(false);
          }
        };
      });

      var _require6 = require('./routes'),
          applyAuthRoutes = _require6.applyAuthRoutes;

      var server = express();
      server.use(express.json());
      var router = express.Router();
      server.use('/', router);
      applyAuthRoutes(router, functions);
      return request(server).post(endpoints.signInUrl).expect(400).send({}).then(function (res) {
        expect(res.body.errorType).toMatch('INVALID_CREDENTIALS');
        return null;
      });
    });
  });
});