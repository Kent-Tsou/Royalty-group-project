"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-disable jest/no-done-callback */
beforeEach(function () {
  return jest.resetModules();
});
describe('token', function () {
  it('getIssuer returns a token issuer middleware function', function (done) {
    jest.mock('jsonwebtoken', function () {
      return {
        sign: function sign() {
          return 'test-token';
        }
      };
    });

    var token = require('./token');

    expect.assertions(3);
    var req = {
      body: {
        username: 'test-user'
      }
    };
    var res = {
      json: function json(_ref) {
        var token = _ref.token,
            message = _ref.message;
        expect(token).toBe('test-token');
        expect(message).toBe('Authentication successful.');
        done();
      }
    };

    var getUserByName = function getUserByName(username) {
      expect(username).toBe(req.body.username);
      return Promise.resolve({
        id: 1,
        username: username
      });
    };

    token.getIssuer(getUserByName)(req, res);
  });
  it('getIssuer returns a token with a defined expiration time', function (done) {
    expect.assertions(1);
    jest.mock('jsonwebtoken', function () {
      return {
        sign: function sign(token, secret, expires) {
          return {
            token: token,
            secret: secret,
            expires: expires
          };
        }
      };
    });
    var jwtExpireTime = '5h';
    process.env.JWT_EXPIRE_TIME = jwtExpireTime;

    var token = require('./token');

    var res = {
      json: function json(_ref2) {
        var token = _ref2.token;
        expect(token.expires.expiresIn).toBe(jwtExpireTime);
        delete process.env.JWT_EXPIRE_TIME;
        done();
      }
    };

    var getUserByName = function getUserByName() {
      return Promise.resolve();
    };

    token.getIssuer(getUserByName)({
      body: {}
    }, res);
  });
  it('getIssuer returns a token with a default expiration time', function (done) {
    expect.assertions(1);
    jest.mock('jsonwebtoken', function () {
      return {
        sign: function sign(token, secret, expires) {
          return {
            token: token,
            secret: secret,
            expires: expires
          };
        }
      };
    });

    var token = require('./token');

    var res = {
      json: function json(_ref3) {
        var token = _ref3.token;
        expect(token.expires.expiresIn).toBe('1d');
        done();
      }
    };

    var getUserByName = function getUserByName() {
      return Promise.resolve({});
    };

    token.getIssuer(getUserByName)({
      body: {}
    }, res);
  });
  it('default expiration time is 1 day', function () {
    jest.mock('jsonwebtoken', function () {
      return {
        sign: function sign(token, secret, expires) {
          return {
            token: token,
            secret: secret,
            expires: expires
          };
        }
      };
    });

    var token = require('./token');

    var testToken = token.createToken({}, 'test-secret');
    expect(testToken.expires.expiresIn).toBe('1d');
  });
  it('decode invokes the express-jwt middleware function', function () {
    expect.assertions(5);
    jest.mock('express-jwt', function () {
      return function (_ref4) {
        var secret = _ref4.secret;
        expect(_typeof(secret)).toBe('function');
        return function (req, res, next) {
          expect(req).toBe('req');
          expect(res).toBe('res');
          expect(next).toBe('next');
        };
      };
    });
    jest.spyOn(console, 'warn').mockImplementation(function () {});

    var token = require('./token');

    token.decode('req', 'res', 'next');
    expect(console.warn).toHaveBeenCalled();
    console.warn.mockRestore();
  });
  it('createToken returns a signed token', function () {
    jest.mock('jsonwebtoken', function () {
      return {
        sign: function sign() {
          return 'test-token';
        }
      };
    });

    var token = require('./token');

    var testToken = token.createToken({}, 'test-secret');
    expect(testToken).toBe('test-token'); // from the mock at the top of the file
  });
  it('getTokenDecoder invokes the express-jwt middleware function', function () {
    // TODO: I'm not thrilled with this test. What is it _really_ testing?
    expect.assertions(5);
    jest.mock('express-jwt', function () {
      return function (_ref5) {
        var secret = _ref5.secret;
        expect(_typeof(secret)).toBe('function');
        return function (req, res, next) {
          expect(req).toBe('req');
          expect(res).toBe('res');
          expect(next).toBe('next');
        };
      };
    });

    var tokenDecoder = require('./token').getTokenDecoder();

    expect(_typeof(tokenDecoder)).toBe('function');
    tokenDecoder('req', 'res', 'next');
  });
});